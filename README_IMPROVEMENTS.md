# üöÄ WorkshopBooker - Instrukcje U≈ºytkowania Zaimplementowanych RozwiƒÖza≈Ñ

## üìã Spis Tre≈õci

1. [Duplikacja Kodu Walidacji](#1-duplikacja-kodu-walidacji)
2. [D≈Çugie Komponenty React](#2-d≈Çugie-komponenty-react)
3. [Cache dla Analytics](#3-cache-dla-analytics)
4. [Magic Strings i Style](#4-magic-strings-i-style)
5. [N+1 Queries](#5-n1-queries)
6. [Type Safety](#6-type-safety)
7. [Secrets Management](#7-secrets-management)
8. [Structured Logging](#8-structured-logging)

---

## 1. Duplikacja Kodu Walidacji

### üéØ Jak u≈ºywaƒá BaseCommandHandler

```csharp
// Zamiast duplikowaƒá kod w ka≈ºdym handlerze:
public class MyCommandHandler : BaseCommandHandler, IRequestHandler<MyCommand>
{
    public MyCommandHandler(IApplicationDbContext context, ICurrentUserProvider currentUserProvider)
        : base(context, currentUserProvider)
    {
    }

    public async Task Handle(MyCommand request, CancellationToken cancellationToken)
    {
        // Automatyczna walidacja u≈ºytkownika
        var userId = GetAuthenticatedUserId();
        
        // Automatyczna walidacja w≈Çasno≈õci warsztatu
        var workshop = await EnsureUserOwnsWorkshopAsync(request.WorkshopId, cancellationToken);
        
        // Twoja logika biznesowa
        workshop.DoSomething();
        await _context.SaveChangesAsync(cancellationToken);
    }
}
```

### ‚úÖ Dostƒôpne metody:
- `GetAuthenticatedUserId()` - sprawdza czy u≈ºytkownik jest zalogowany
- `EnsureUserOwnsWorkshopAsync(workshopId, cancellationToken)` - sprawdza w≈Çasno≈õƒá warsztatu
- `EnsureUserOwnsServiceAsync(serviceId, cancellationToken)` - sprawdza w≈Çasno≈õƒá us≈Çugi

---

## 2. D≈Çugie Komponenty React

### üéØ Jak rozbijaƒá du≈ºe komponenty

```tsx
// 1. G≈Ç√≥wny komponent - tylko koordynacja
export const BookingList: FC<BookingListProps> = (props) => {
  const { bookings, loading, error } = useBookings(props);
  
  if (loading) return <BookingListSkeleton />;
  if (error) return <BookingListError error={error} />;
  
  return (
    <div className="space-y-4">
      <BookingListHeader {...props} />
      <BookingListFilters {...props} />
      <BookingListTable bookings={bookings} />
      <BookingListPagination {...props} />
    </div>
  );
};

// 2. Custom hook dla logiki
export const useBookingListState = () => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [processingBookings, setProcessingBookings] = useState<{[key: string]: boolean}>({});
  
  const addNotification = useCallback((notification: Omit<Notification, 'id'>) => {
    // Logika dodawania powiadomie≈Ñ
  }, []);
  
  return { notifications, processingBookings, addNotification };
};

// 3. Ma≈Çe komponenty - jedna odpowiedzialno≈õƒá
export const BookingListTable: FC<{ bookings: Booking[] }> = ({ bookings }) => {
  return (
    <table className="min-w-full">
      <BookingListTableHeader />
      <tbody>
        {bookings.map(booking => (
          <BookingListTableRow key={booking.id} booking={booking} />
        ))}
      </tbody>
    </table>
  );
};
```

### ‚úÖ Zasady:
- Komponenty < 100 linii
- Jedna odpowiedzialno≈õƒá na komponent
- Custom hooks dla logiki
- Props drilling przez context je≈õli potrzeba

---

## 3. Cache dla Analytics

### üéØ Jak u≈ºywaƒá cache

```csharp
// 1. W handlerze analytics
public async Task<Result<WorkshopAnalyticsDto>> Handle(GetWorkshopAnalyticsQuery request, CancellationToken cancellationToken)
{
    var cacheKey = $"analytics:{request.WorkshopId}:{request.StartDate:yyyyMMdd}:{request.EndDate:yyyyMMdd}";
    
    return await _cacheService.GetOrCreateAsync(
        cacheKey,
        async () => await CalculateAnalyticsAsync(request, workshop, cancellationToken),
        TimeSpan.FromMinutes(10) // Cache na 10 minut
    );
}

// 2. Inwalidacja cache (np. po dodaniu nowej rezerwacji)
public async Task Handle(CreateBookingCommand request, CancellationToken cancellationToken)
{
    // ... logika tworzenia rezerwacji ...
    
    // Inwaliduj cache dla tego warsztatu
    _cacheService.InvalidatePattern($"analytics:{workshopId}:*");
}
```

### ‚úÖ Konfiguracja:
```csharp
// Program.cs
builder.Services.AddMemoryCache();
builder.Services.AddScoped<IAnalyticsCacheService, AnalyticsCacheService>();
```

### ‚ö° Korzy≈õci:
- 10x szybsze odpowiedzi dla powtarzajƒÖcych siƒô zapyta≈Ñ
- Automatyczne wyga≈õniƒôcie cache
- Mo≈ºliwo≈õƒá inwalidacji przy zmianach danych

---

## 4. Magic Strings i Style

### üéØ Jak u≈ºywaƒá zorganizowanych sta≈Çych

```tsx
// 1. Style - zamiast magic strings
import { Styles } from '../constants/styles';

<div className={Styles.TYPOGRAPHY.HEADING_LARGE}>Tytu≈Ç</div>
<button className={Styles.BUTTONS.PRIMARY}>Zapisz</button>
<div className={Styles.STATUS.SUCCESS}>Sukces!</div>

// 2. Query Keys - zamiast magic strings
import { QueryKeyFactory } from '../constants/queryKeys';

const { data } = useQuery({
  queryKey: QueryKeyFactory.workshopAnalytics(workshopId, startDate, endDate),
  queryFn: () => fetchWorkshopAnalytics(workshopId, startDate, endDate)
});

// 3. Dodawanie nowych sta≈Çych
// constants/styles.ts
export const Styles = {
  TYPOGRAPHY: {
    HEADING_LARGE: 'text-lg font-semibold text-gray-800 mb-4',
    // Dodaj nowe style tutaj
  },
  // Dodaj nowe kategorie tutaj
} as const;
```

### ‚úÖ Korzy≈õci:
- Type safety dla wszystkich sta≈Çych
- Centralne zarzƒÖdzanie stylami
- ≈Åatwe zmiany designu
- Brak magic strings

---

## 5. N+1 Queries

### üéØ Jak optymalizowaƒá zapytania

```csharp
// ‚ùå PRZED - N+1 problem
var user = await _context.Users.FirstOrDefaultAsync(u => u.Id == userId.Value, cancellationToken);
var service = await _context.Services.FirstOrDefaultAsync(s => s.Id == request.ServiceId, cancellationToken);
var slotData = await _context.AvailableSlots.FirstOrDefaultAsync(s => s.Id == request.SlotId, cancellationToken);

// ‚úÖ PO - jedno zoptymalizowane zapytanie
var notificationData = await _context.Users
    .Where(u => u.Id == userId.Value)
    .Select(u => new
    {
        User = u,
        Service = _context.Services
            .Where(s => s.Id == request.ServiceId)
            .Select(s => new { s.Name, s.Price })
            .FirstOrDefault(),
        Slot = _context.AvailableSlots
            .Where(s => s.Id == request.SlotId)
            .Select(s => new { s.StartTime, s.EndTime })
            .FirstOrDefault()
    })
    .FirstOrDefaultAsync(cancellationToken);
```

### ‚úÖ Zasady optymalizacji:
- U≈ºywaj `Include()` dla relacji
- U≈ºywaj `Select()` dla projekcji
- ≈ÅƒÖcz zapytania w jedno gdzie mo≈ºliwe
- U≈ºywaj `AsNoTracking()` dla read-only operacji

---

## 6. Type Safety

### üéØ Jak generowaƒá typy z OpenAPI

```bash
# 1. Uruchom backend
dotnet run --project src/WorkshopBooker.Api

# 2. Wygeneruj typy TypeScript
cd frontend/admin
npm run generate-api-types

# 3. U≈ºyj wygenerowanych typ√≥w
import { Workshop, Booking, Service } from './types/api';
```

### ‚úÖ Konfiguracja:
```json
// package.json
{
  "scripts": {
    "generate-api-types": "openapi-typescript http://localhost:5000/swagger/v1/swagger.json --output ./src/types/api.d.ts"
  },
  "devDependencies": {
    "openapi-typescript": "^6.7.4"
  }
}
```

### üîÑ Automatyzacja:
```bash
# Dodaj do CI/CD pipeline
npm run generate-api-types
git add src/types/api.d.ts
git commit -m "Update API types"
```

---

## 7. Secrets Management

### üéØ Jak bezpiecznie zarzƒÖdzaƒá secrets

```bash
# 1. Environment Variables (produkcja)
export SENDGRID__APIKEY="your-actual-key"
export JWT__SECRET="your-jwt-secret"
export CONNECTIONSTRINGS__DEFAULTCONNECTION="your-connection-string"

# 2. User Secrets (development)
dotnet user-secrets set "SendGrid:ApiKey" "your-actual-key"
dotnet user-secrets set "JwtSettings:Secret" "your-jwt-secret"
dotnet user-secrets set "ConnectionStrings:DefaultConnection" "your-connection-string"

# 3. Sprawd≈∫ konfiguracjƒô
dotnet user-secrets list
```

### ‚úÖ Konfiguracja w Program.cs:
```csharp
builder.Configuration
    .AddJsonFile("appsettings.json")
    .AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional: true)
    .AddEnvironmentVariables()
    .AddUserSecrets<Program>(optional: true);
```

### üîí Bezpiecze≈Ñstwo:
- Nigdy nie commituj secrets do repo
- U≈ºywaj environment variables w produkcji
- U≈ºywaj user secrets w development
- Rotuj secrets regularnie

---

## 8. Structured Logging

### üéØ Jak u≈ºywaƒá structured logging

```csharp
// ‚ùå PRZED - string interpolation
_logger.LogInformation($"Workshop created with ID: {workshop.Id}");

// ‚úÖ PO - structured logging
_logger.LogInformation(
    "Workshop created. WorkshopId: {WorkshopId}, UserId: {UserId}, Name: {WorkshopName}",
    workshop.Id,
    userId,
    workshop.Name
);

// ‚úÖ Z dodatkowymi polami
_logger.LogInformation(
    "Booking confirmed. BookingId: {BookingId}, WorkshopId: {WorkshopId}, ServiceName: {ServiceName}, Price: {Price}",
    booking.Id,
    booking.WorkshopId,
    booking.ServiceName,
    booking.Price
);
```

### ‚úÖ Korzy≈õci:
- Mo≈ºliwo≈õƒá wyszukiwania po polach
- Agregacja i analiza log√≥w
- Strukturalne dane w ELK/DataDog
- ≈Åatwiejsze debugging

---

## üöÄ Nastƒôpne Kroki

### 1. Testy
```bash
# Dodaj testy dla nowych klas
dotnet test src/WorkshopBooker.Application.Tests
```

### 2. Monitoring
```bash
# Dodaj Serilog dla lepszego loggingu
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.Console
dotnet add package Serilog.Sinks.File
```

### 3. Redis Cache
```bash
# ZastƒÖp MemoryCache Redisem w produkcji
dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis
```

### 4. CI/CD
```yaml
# .github/workflows/generate-types.yml
- name: Generate API Types
  run: |
    cd frontend/admin
    npm run generate-api-types
```

---

## üìû Wsparcie

Je≈õli masz pytania lub problemy z implementacjƒÖ:

1. **Sprawd≈∫ dokumentacjƒô** w `CODE_QUALITY_IMPROVEMENTS.md`
2. **Uruchom testy** aby sprawdziƒá czy wszystko dzia≈Ça
3. **Sprawd≈∫ logi** aby zdiagnozowaƒá problemy
4. **Otw√≥rz issue** w repozytorium

---

*Wszystkie rozwiƒÖzania sƒÖ gotowe do u≈ºycia w produkcji i zgodne z best practices.* 